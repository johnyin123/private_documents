#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(__WIN32__)
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #define close_socket closesocket
    typedef int socklen_t;
#else
    #define close_socket close
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <netinet/tcp.h>
    #include <fcntl.h>
#endif

int process_request(const char *req, const ssize_t req_len, int fd) {
    const char *msg = "HTTP/1.1 200 OK\r\n"
        "Content-Type: text/plain\r\n"
        "Connection: close\r\n"
        "\r\n"
        "message";
    return send(fd, msg, strlen(msg), 0) > 0;
}

#define HTTP_PORT 8080
#define BUFSIZE 1024
struct sock_pool_t {
    int  max_fd;
    int  srv_sock;
    int  cli_sock[FD_SETSIZE];
    int  req_len[FD_SETSIZE];
    char request[FD_SETSIZE][BUFSIZE];
    fd_set read_set;
    fd_set ready_set;
};
static struct sock_pool_t pool;

static int set_sock_nonblock_nodelay(int fd) {
    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *)&(int){1}, sizeof(int));
#if defined(__WIN32__)
    unsigned long mode = 1;
    return ioctlsocket(fd, FIONBIO, &mode);
#else
    int flags = fcntl(fd, F_GETFL);
    return (flags < 0) ? -1 : fcntl(fd, F_SETFL, flags | O_NONBLOCK);
#endif
}

static int create_tcp_server(const char *addr, int port, int backlog) {
    int srv_sock;
    struct sockaddr_in sa = { .sin_family = AF_INET, .sin_addr.s_addr = inet_addr(addr), .sin_port = htons(port) };
    if ((srv_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) return -1;
    setsockopt(srv_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&(int){1}, sizeof(int));
    set_sock_nonblock_nodelay(srv_sock);
    if (bind(srv_sock,(struct sockaddr*)&sa,sizeof(sa)) == -1 || listen(srv_sock, backlog) == -1) {
        close_socket(srv_sock);
        return -1;
    }
    return srv_sock;
}

static void check_clients(struct sock_pool_t *p) {
    for(int i=0; i<FD_SETSIZE; i++) {
        int cli_sock = p->cli_sock[i];
        if ((cli_sock > 0) && (FD_ISSET(cli_sock, &p->ready_set))) {
            const ssize_t ret = recv(cli_sock, p->request[i]+p->req_len[i], BUFSIZE - p->req_len[i], 0);
            if (ret > 0) {
                p->req_len[i] += ret;
                p->request[i][p->req_len[i]] = '\0';
                if (strstr(p->request[i], "\r\n\r\n")) {
                    process_request(p->request[i], p->req_len[i], cli_sock);
                    goto close_conn;
                } else {
                    /* not a valid request */
                    fprintf(stderr, "sock=%d, not valid request\n", cli_sock);
                }
                continue;
            } else {
                /* Connection closed or error */
                goto close_conn;
            }
        close_conn:
            // find the new max
            if (cli_sock == p->max_fd) {
                p->max_fd = p->srv_sock; // Start with base server socket
                for (int j = 0; j < FD_SETSIZE; j++) {
                    if (p->cli_sock[j] > p->max_fd) {
                        p->max_fd = p->cli_sock[j];
                    }
                }
            }
            close_socket(cli_sock);
            FD_CLR(cli_sock, &p->read_set);
            p->cli_sock[i] = -1;
        }
    }
}
static void accept_client(struct sock_pool_t *p) {
    int cli_sock;
    if ((cli_sock = accept(p->srv_sock, NULL, NULL)) == -1) {
        perror("accept");
        close_socket(p->srv_sock);
        exit(EXIT_FAILURE);
    }
    set_sock_nonblock_nodelay(cli_sock);
    /*add client*/
    for(int i=0; i<FD_SETSIZE; i++) {
        if (p->cli_sock[i] < 0) {
            p->cli_sock[i] = cli_sock;
            FD_SET(cli_sock, &p->read_set);
            memset(p->request[i], 0, BUFSIZE);
            p->req_len[i] = 0;
            if (cli_sock>p->max_fd) p->max_fd = cli_sock;
            return;
        }
    }
    fprintf(stderr, "add_client error: Too many clients\n");
}

int main(const int argc, char const* argv[]) {
#if defined(__WIN32__)
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2 ,2), &wsaData);
    if (iResult != 0) {
        printf("error at WSASturtup\n");
        return 0;
    }
#endif
    if ((pool.srv_sock = create_tcp_server("127.0.0.1", HTTP_PORT, 10)) == -1) {
        perror("Create socket");
        exit(EXIT_FAILURE);
    }

    pool.max_fd = pool.srv_sock;
    for(int i=0; i<FD_SETSIZE; i++) {
        pool.cli_sock[i] = -1;
    }
    FD_ZERO(&pool.read_set);
    FD_SET(pool.srv_sock, &pool.read_set);

    for(;;) {
        int nready;
        pool.ready_set = pool.read_set;
        struct timeval timeout;
        timeout.tv_sec = 2;
        timeout.tv_usec = 0;
        if ((nready = select(pool.max_fd + 1, &pool.ready_set, NULL, NULL, &timeout))==-1) {
            perror("select");
            exit(EXIT_FAILURE);
        }
        if (nready==0) continue; /*timeout*/
        if (FD_ISSET(pool.srv_sock, &pool.ready_set)) {
            accept_client(&pool);
            nready--;
        }
        if(nready > 0) {
            check_clients(&pool);
        }
    }
#if defined(__WIN32__)
    WSACleanup();
#endif
}
