#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#if defined(__WIN32__)
    #include <winsock2.h>
    #include <ws2tcpip.h>
    #define close_socket closesocket
    typedef int socklen_t;
#else
    #define close_socket close
    #include <sys/socket.h>
    #include <arpa/inet.h>
    #include <unistd.h>
    #include <netinet/tcp.h>
    #include <fcntl.h>
#endif
enum mime_t { JSON = 0, TEXT };
static const char *mime_str(enum mime_t m) {
    switch (m) {
        case JSON:       return "application/json";
        case TEXT:       return "text/plain; charset=utf-8";
        default:         return "application/octet-stream";
    }
}
static const char *status_str(unsigned int s) {
    switch (s) {
        case 200: return "200 OK";
        case 403: return "403 Forbidden";
        case 404: return "404 Not Found";
        default:  return "500 Internal Server Error";
    }
}
int make_response(int fd, unsigned int status, int mime, const char *body, size_t body_len) {
    char dest[4096];
    int len = snprintf(dest, sizeof(dest) - 1, "HTTP/1.1 %s\r\nContent-Type: %s\r\nContent-Length: %zu\r\n\r\n%s", status_str(status), mime_str(mime), body_len, body);
    if(len > 0) return send(fd, dest, len, 0) > 0;
    return -1;
}
int process_request(const char *req, const ssize_t req_len, int fd) {
    char method[16], uri[2048];
    int vhi, vlo;
    if (4 != sscanf(req, "%15[A-Z] %2047[^ \t\r\n] HTTP/%d.%d\r\n",method, uri, &vhi, &vlo)) {
        return make_response(fd, 500, TEXT, "internal", 8);
    }
    if (strcmp(method, "GET") == 0) {
        return make_response(fd, 200, JSON, uri, strlen(uri));
    }
    else if (strcmp(method, "POST") == 0) {
        return make_response(fd, 200, JSON, uri, strlen(uri));
    }
    return make_response(fd, 403, TEXT, "Forbidden", 9);
}

#define HTTP_PORT 8080
#define BUFSIZE 1024
struct sock_pool_t {
    int  max_fd;
    int  srv_sock;
    int  cli_sock[FD_SETSIZE];
    int  req_len[FD_SETSIZE];
    char request[FD_SETSIZE][BUFSIZE];
    fd_set read_set;
    fd_set ready_set;
};
static int set_sock_nonblock_nodelay(int fd) {
    setsockopt(fd, IPPROTO_TCP, TCP_NODELAY, (void *)&(int){1}, sizeof(int));
#if defined(__WIN32__)
    unsigned long mode = 1;
    return ioctlsocket(fd, FIONBIO, &mode);
#else
    int flags = fcntl(fd, F_GETFL);
    return (flags < 0) ? -1 : fcntl(fd, F_SETFL, flags | O_NONBLOCK);
#endif
}

static int create_tcp_server(const char *addr, int port, int backlog) {
    int srv_sock;
    struct sockaddr_in sa = { .sin_family = AF_INET, .sin_addr.s_addr = inet_addr(addr), .sin_port = htons(port) };
    if ((srv_sock = socket(AF_INET, SOCK_STREAM, 0)) == -1) return -1;
    setsockopt(srv_sock, SOL_SOCKET, SO_REUSEADDR, (void *)&(int){1}, sizeof(int));
    set_sock_nonblock_nodelay(srv_sock);
    if (bind(srv_sock,(struct sockaddr*)&sa,sizeof(sa)) == -1 || listen(srv_sock, backlog) == -1) {
        close_socket(srv_sock);
        return -1;
    }
    return srv_sock;
}

static void check_clients(struct sock_pool_t *p) {
    for(int i=0; i<FD_SETSIZE; i++) {
        int cli_sock = p->cli_sock[i];
        if ((cli_sock > 0) && (FD_ISSET(cli_sock, &p->ready_set))) {
            const ssize_t ret = recv(cli_sock, p->request[i]+p->req_len[i], BUFSIZE - p->req_len[i], 0);
            if (ret > 0) {
                p->req_len[i] += ret;
                p->request[i][p->req_len[i]] = '\0';
                if (strstr(p->request[i], "\r\n\r\n")) {
                    process_request(p->request[i], p->req_len[i], cli_sock);
                    goto close_conn;
                } else {
                    /* not a valid request */
                    fprintf(stderr, "sock=%d, not valid request\n", cli_sock);
                }
                continue;
            } else {
                /* Connection closed or error */
                goto close_conn;
            }
        close_conn:
            // find the new max
            if (cli_sock == p->max_fd) {
                p->max_fd = p->srv_sock; // Start with base server socket
                for (int j = 0; j < FD_SETSIZE; j++) {
                    if (p->cli_sock[j] > p->max_fd) {
                        p->max_fd = p->cli_sock[j];
                    }
                }
            }
            close_socket(cli_sock);
            FD_CLR(cli_sock, &p->read_set);
            p->cli_sock[i] = -1;
        }
    }
}
static void accept_client(struct sock_pool_t *p) {
    int cli_sock;
    if ((cli_sock = accept(p->srv_sock, NULL, NULL)) == -1) {
        perror("accept");
        close_socket(p->srv_sock);
        exit(EXIT_FAILURE);
    }
    set_sock_nonblock_nodelay(cli_sock);
    /*add client*/
    for(int i=0; i<FD_SETSIZE; i++) {
        if (p->cli_sock[i] < 0) {
            p->cli_sock[i] = cli_sock;
            FD_SET(cli_sock, &p->read_set);
            memset(p->request[i], 0, BUFSIZE);
            p->req_len[i] = 0;
            if (cli_sock>p->max_fd) p->max_fd = cli_sock;
            return;
        }
    }
    fprintf(stderr, "add_client error: Too many clients\n");
}

static struct sock_pool_t pool;
int main(const int argc, char const* argv[]) {
#if defined(__WIN32__)
    WSADATA wsaData;
    int iResult = WSAStartup(MAKEWORD(2 ,2), &wsaData);
    if (iResult != 0) {
        printf("error at WSASturtup\n");
        return 0;
    }
#endif
    struct timeval timeout = { .tv_sec = 2, .tv_usec = 0, };
    if ((pool.srv_sock = create_tcp_server("127.0.0.1", HTTP_PORT, 10)) == -1) {
        perror("Create socket");
        exit(EXIT_FAILURE);
    }
    pool.max_fd = pool.srv_sock;
    for(int i=0; i<FD_SETSIZE; i++) {
        pool.cli_sock[i] = -1;
    }
    FD_ZERO(&pool.read_set);
    FD_SET(pool.srv_sock, &pool.read_set);
    for(;;) {
        pool.ready_set = pool.read_set;
        int nready = select(pool.max_fd + 1, &pool.ready_set, NULL, NULL, &timeout);
        if(nready > 0) {
            if (FD_ISSET(pool.srv_sock, &pool.ready_set)) {
                accept_client(&pool);
            }
            check_clients(&pool);
        } else if(nready < 0) {
            perror("select");
            exit(EXIT_FAILURE);
        }
        // if(nready==0) { fprintf(stderr, "select timeout\n"); continue; /*timeout*/ }
    }
#if defined(__WIN32__)
    WSACleanup();
#endif
}
