#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging, os
logging.basicConfig(encoding='utf-8', format='[%(funcName)s@%(filename)s(%(lineno)d)]%(name)s %(levelname)s: %(message)s')
logger = logging.getLogger(__name__)
logger.setLevel(level=os.getenv('LOG', 'INFO').upper())

import etcd3
import json
import time
import threading

# Define a key for shared JSON data
SHARED_JSON_KEY = '/app/config/settings'

def node_process(node_id):
    print(f"[{node_id}] Starting ...")
    etcd = etcd3.client(host='localhost', port=2379)
    initial_data = {'node_activity': {}, 'nodeid': node_id}
    etcd.put_if_not_exists(SHARED_JSON_KEY, json.dumps(initial_data))
    # status = etcd.replace(SHARED_JSON_KEY, 'toot', 'doot')
    # assert v == b'doot'
    for i in range(5):  # Simulate multiple interactions
        # 1. Acquire a distributed lock to prevent race conditions during updates
        try:
            with etcd.lock(f'lock-{SHARED_JSON_KEY}', ttl=3) as lock: # ttl added for robustness
                if lock.is_acquired():
                    current_json_str, metadata = etcd.get(SHARED_JSON_KEY)
                    current_data = json.loads(current_json_str)
                    # 3. Modify the JSON data (e.g., update node activity)
                    current_data['node_activity'][node_id] = f'update_{i}'
                    # 4. Write back, Use compare-and-swap (via a transaction) for atomic updates
                    etcd.transaction(
                        compare=[etcd.transactions.value(SHARED_JSON_KEY) == current_json_str],
                        success=[etcd.transactions.put(SHARED_JSON_KEY, json.dumps(current_data))],
                        failure=[]
                    )
                    print(f"[{node_id}] Updated shared JSON: {current_data}")
                else:
                    print(f"[{node_id}] Failed to acquire lock, another node is writing. Retrying in a moment.")
        except Exception as e:
            print(f"[{node_id}] ---------------- ted before us: {e}")
        time.sleep(1) # Simulate some work

def watch_node(node_id):
    """Watches for changes to the shared JSON data."""
    print(f"[{node_id}] Watching for changes to {SHARED_JSON_KEY}")
    etcd = etcd3.client(host='localhost', port=2379)
    # events_iterator, cancel = etcd.watch(SHARED_JSON_KEY) 
    events_iterator, cancel = etcd.watch_prefix(SHARED_JSON_KEY) 
    for event in events_iterator:
        if isinstance(event, etcd3.events.PutEvent):
            try:
                updated_data = json.loads(event.value)
            except json.JSONDecodeError:
                logging.error(f"[{self.node_id}] Could not decode JSON from etcd event: {sub_event.value.decode('utf-8')}")
        elif isinstance(event, etcd3.events.DeleteEvent):
            updated_data = {}
        print(f"[{node_id}] Received etcd event: {event}")

if __name__ == "__main__":
    # Start multiple node processes concurrently
    num_nodes = 5
    threads = []
    for i in range(num_nodes):
        node_id = f"Node-{i+1}"
        thread = threading.Thread(target=node_process, args=(node_id,))
        threads.append(thread)
        thread.start()

    # Start a watcher thread
    watcher_thread = threading.Thread(target=watch_node, args=("Watcher",))
    watcher_thread.start()

    # Wait for all node threads to finish
    for thread in threads:
        thread.join()

    # Allow the watcher to catch the final updates
    time.sleep(2)
    print("Demo finished.")
