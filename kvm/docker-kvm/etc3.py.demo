#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import logging, os
logging.basicConfig(encoding='utf-8', format='[%(funcName)s@%(filename)s(%(lineno)d)]%(name)s %(levelname)s: %(message)s')
logger = logging.getLogger(__name__)
logger.setLevel(level=os.getenv('LOG', 'INFO').upper())

import etcd3
import json
import time
import threading

# Define a key for shared JSON data
SHARED_JSON_KEY = '/app/config/settings'

def node_process(node_id):
    print(f"[{node_id}] Starting ...")
    etcd = etcd3.client(host='localhost', port=2379)
    initial_data = {'node_activity': {}, 'nodeid': node_id}
    etcd.put_if_not_exists(SHARED_JSON_KEY, json.dumps(initial_data))
    # status = etcd.replace(SHARED_JSON_KEY, 'toot', 'doot')
    # assert v == b'doot'
    for i in range(5):  # Simulate multiple interactions
        # 1. Acquire a distributed lock to prevent race conditions during updates
        try:
            with etcd.lock(f'lock-{SHARED_JSON_KEY}', ttl=3) as lock: # ttl added for robustness
                if lock.is_acquired():
                    current_json_str, metadata = etcd.get(SHARED_JSON_KEY)
                    current_data = json.loads(current_json_str)
                    # 3. Modify the JSON data (e.g., update node activity)
                    current_data['node_activity'][node_id] = f'update_{i}'
                    # 4. Write back, Use compare-and-swap (via a transaction) for atomic updates
                    etcd.transaction(
                        compare=[etcd.transactions.value(SHARED_JSON_KEY) == current_json_str],
                        success=[etcd.transactions.put(SHARED_JSON_KEY, json.dumps(current_data))],
                        failure=[]
                    )
                    print(f"[{node_id}] Updated shared JSON: {current_data}")
                else:
                    print(f"[{node_id}] Failed to acquire lock, another node is writing. Retrying in a moment.")
        except Exception as e:
            print(f"[{node_id}] ---------------- ted before us: {e}")
        time.sleep(1) # Simulate some work

def watch_node(node_id):
    """Watches for changes to the shared JSON data."""
    print(f"[{node_id}] Watching for changes to {SHARED_JSON_KEY}")
    etcd = etcd3.client(host='localhost', port=2379)
    # events_iterator, cancel = etcd.watch(SHARED_JSON_KEY) 
    events_iterator, cancel = etcd.watch_prefix(SHARED_JSON_KEY) 
    for event in events_iterator:
        if isinstance(event, etcd3.events.PutEvent):
            try:
                updated_data = json.loads(event.value)
            except json.JSONDecodeError:
                logging.error(f"[{self.node_id}] Could not decode JSON from etcd event: {sub_event.value.decode('utf-8')}")
        elif isinstance(event, etcd3.events.DeleteEvent):
            updated_data = {}
        print(f"[{node_id}] Received etcd event: {event}")

if __name__ == "__main__":
    # Start multiple node processes concurrently
    num_nodes = 5
    threads = []
    for i in range(num_nodes):
        node_id = f"Node-{i+1}"
        thread = threading.Thread(target=node_process, args=(node_id,))
        threads.append(thread)
        thread.start()

    # Start a watcher thread
    watcher_thread = threading.Thread(target=watch_node, args=("Watcher",))
    watcher_thread.start()

    # Wait for all node threads to finish
    for thread in threads:
        thread.join()

    # Allow the watcher to catch the final updates
    time.sleep(2)
    print("Demo finished.")
# -*- coding: utf-8 -*-
import logging, datetime, os, utils, multiprocessing, json, random, config
from typing import Iterable, Optional, Set, List, Tuple, Union, Dict, Generator
logging.basicConfig(encoding='utf-8', format='[%(funcName)s@%(filename)s(%(lineno)d)]%(name)s %(levelname)s: %(message)s')
logger = logging.getLogger(__name__)
logger.setLevel(level=os.getenv('LOG', 'INFO').upper())

# DATA_DIR=/home/johnyin/disk/mygit/github_private/kvm/docker-kvm/test/work
# PREFIX=/home/johnyin/disk/mygit/github_private/kvm/docker-kvm/test/work
# for f in ${DATA_DIR}/*.json; do
#   etcdctl put ${PREFIX}/${f##*/} '$(cat ${f})'
# done

class etcd_task:
    cache = {
        os.path.join(config.DATA_DIR, 'hosts.json'):utils.manager.list(),
        os.path.join(config.DATA_DIR, 'devices.json'):utils.manager.list(),
        os.path.join(config.DATA_DIR, 'golds.json'):utils.manager.list(),
        os.path.join(config.DATA_DIR, 'iso.json'):utils.manager.list(),
    }
    lock = None

import etcd3
def watch_etcd(dic, prefix:str):
    etcd = etcd3.client(host='localhost', port=2379)
    for k, v in dic.items():
        value, meta = etcd.get(k)
        logger.info(f'Init {value}')
        dic[k] = [utils.manager.dict(item) for item in json.loads(value)]
    #for value, meta in list(etcd.get_prefix(prefix, keys_only=True)):
    _iter, _cancel = etcd.watch_prefix(prefix)
    for event in _iter:
        # if stop_event_obj.is_set():
        #     logging.info("Watcher thread received stop signal. Exiting.")
        #     return
        try:
            if isinstance(event, etcd3.events.PutEvent):
                updated_data = json.loads(event.value)
            elif isinstance(event, etcd3.events.DeleteEvent):
                updated_data = {}
        except json.JSONDecodeError:
            logging.error(f'decode JSON from etcd event: {event}')

import threading
threading.Thread(target=watch_etcd, args=(etcd_task.cache, config.DATA_DIR,), daemon=True).start()

import time
time.sleep(2)
logger.info(f'Demo finished. {etcd_task.cache}')

