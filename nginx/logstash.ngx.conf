# cat /var/log/nginx/access.log | while IFS= read -r line ; do
#     logger -p local7.info --rfc3164 -t ngx_access --server 192.168.168.123 --port 5140 "$line"
# done
cat<<EOF
sysctl -w vm.max_map_count=262144
cd elasticsearch-9.2.1
cat <<EO_ELK >> config/elasticsearch.yml
action.auto_create_index:.monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*,nginx-*
cluster.name: elasticsearch-ngx
network.host: 0.0.0.0
transport.host: 0.0.0.0
EO_ELK
./bin/elasticsearch
ls config/certs/http_ca.crt
./bin/elasticsearch-users useradd logstash --password passwrd1 --roles superuser

# # bin/elasticsearch-reset-password -u elastic
# bin/elasticsearch-create-enrollment-token --scope kibana
# kibana/bin/kibana-setup --enrollment-token xx
# # kibana/config/kibana.yml
# server.port: 5601
# server.host: 0.0.0.0
EOF
cat >> config/pipelines.yml <<EOF
- pipeline.id: nginxlog
  pipeline.workers: 2
  pipeline.batch.size: 125
  pipeline.batch.delay: 50
  path.config: "config/logstash.ngx.conf"
EOF
cat >> config/logstash.ngx.conf <<'EOF'
input {
  udp {
    port => 5140
    host => "0.0.0.0"
    type => "syslog"
  }
}
filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{PROG:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
      add_tag => [ "syslog_parsed_ok" ]
    }
    if [syslog_program] == "ngx_error" {
      grok {
        match => { "syslog_message" => "(?<timestamp>%{YEAR}[./]%{MONTHNUM}[./]%{MONTHDAY} %{TIME}) \[%{LOGLEVEL:log_level}\] %{POSINT:pid}#%{NUMBER:threadid}: \*%{NUMBER:connectionid} %{GREEDYDATA:message_content}, client: %{IP:client_ip}, server: %{GREEDYDATA:server_name}, request: %{GREEDYDATA:log_message}" }
        #\"%{GREEDYDATA:request_details}\"(, upstream: \"%{URI:upstream_server}\")?(, host: \"%{IPORHOST:host}\")?(, referrer: \"%{URI:referrer}\")?
        remove_field => [ "message","syslog_message","event" ]
      }
      date {
        match => [ "timestamp", "YYYY/MM/DD HH:mm:ss" ]
        target => "@timestamp"
      }
    }
    if [syslog_program] == "ngx_access" {
      json {
        source => "syslog_message"
        tag_on_failure => ["json_parsed_error"]
        skip_on_invalid_json => true
        remove_field => ["message","event","host","syslog_hostname","syslog_message","syslog_pri","syslog_timestamp","@version","type"]
      }
      mutate { gsub => [    "gzip_ratio", "", "0" ] }
      mutate { convert => { "gzip_ratio" => "float" } }
      mutate { gsub => [    "brotli_ratio", "", "0" ] }
      mutate { convert => { "brotli_ratio" => "float" } }
      mutate { split => {   "upstream_addr" => ", " } }
      mutate { split => {   "upstream_response_time" => ", " } }
      mutate { convert => { "upstream_response_time" => "float" } }
      mutate { split => {   "upstream_status" => ", " } }
      mutate { convert => { "upstream_status" => "integer" } }
      date {
        match => [ "time_iso8601", "ISO8601" ]
        target => "@timestamp"
      }
      useragent {
        source => "http_user_agent"
        target => "ua"
        remove_field => [ "[ua][minor]","[ua][major]","[ua][build]","[ua][patch]","[ua][os_minor]","[ua][os_major]" ]
      }
      if [http_x_forwarded_for] {
        geoip {
          source => "http_x_forwarded_for"
          target => "geoip"
        }
      } else if [remote_addr] {
        geoip {
          source => "remote_addr"
          target => "geoip"
        }
      }
    }
  }
}
output {
  if [syslog_program] == "ngx_error" {
    # elasticsearch {
    #   hosts => ["https://localhost:9200"]
    #   index => "nginx-error-%{+YYYY.MM.dd}"
    #   user => "logstash"
    #   password => "passwrd1"
    #   ssl_enabled => true
    #   ssl_certificate_authorities => "http_ca.crt"
    # }
    stdout { codec => rubydebug }
  }
  if [syslog_program] == "ngx_access" {
    # elasticsearch {
    #   hosts => ["https://localhost:9200"]
    #   index => "nginx-access-%{+YYYY.MM.dd}"
    #   user => "logstash"
    #   password => "passwrd1"
    #   ssl_enabled => true
    #   ssl_certificate_authorities => "http_ca.crt"
    # }
    stdout { codec => rubydebug }
  }
}
EOF
cat <<'EOF'
# list index
curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/_cat/indices?v"
# list all access log
curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/nginx-access-$(date +'%Y.%m.%d')/_search?pretty" \
    -d'{"query":{"match_all":{}}}'

curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/nginx-access-*/_search?pretty" \
    -d'{"query":{"term":{"status": 502}}}'

curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/nginx-access-*/_count?pretty" \
    -d'{"query":{"term":{"status": 502}}}'

curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/nginx-access-*/_search?pretty" \
    -d '{
  "size": 0,
  "aggs": {
    "group_by_uri": {
      "terms": {
        "field": "uri.keyword",
        "size": 10000
      }
    }
  }
}'
curl -k -u logstash:passwrd1 -H 'Content-Type: application/json' \
    "https://localhost:9200/nginx-access-*/_count?pretty" \
    -d '{
    "query": {
    "range": {
      "@timestamp": {
        "gte": "now-5m",
        "lte": "now"
      }
    }
}'
EOF

# # elasticsearch cluster:
# vi /etc/elasticsearch/elasticsearch.yml
cluster.name: elastic-cluster
network.host: 0.0.0.0
# systemctl enable --now elasticsearch
# /usr/share/elasticsearch/bin/elasticsearch-create-enrollment-token -s node
# # On other nodes, join in cluster with an enrollment token
root@node02:~# elasticsearch-reconfigure-node --enrollment-token <token>
root@node02:~# vi /etc/elasticsearch/elasticsearch.yml
cluster.name: elastic-cluster
network.host: 0.0.0.0
root@node02:~# systemctl enable --now elasticsearch
# # Verify Cluster status. If the status is green
# curl -u elastic --cacert /etc/elasticsearch/certs/http_ca.crt https://127.0.0.1:9200/_cat/nodes?v
# curl -u elastic --cacert /etc/elasticsearch/certs/http_ca.crt https://127.0.0.1:9200/_cluster/health?pretty
