cat<<EOF
sysctl -w vm.max_map_count=262144
cd elasticsearch-9.2.1
cat <<EO_ELK >> config/elasticsearch.yml
action.auto_create_index: .monitoring*,.watches,.triggered_watches,.watcher-history*,.ml*,nginx-*
cluster.name: elasticsearch-ngx
network.host: 0.0.0.0
transport.host: 0.0.0.0
EO_ELK
./bin/elasticsearch
ls config/certs/http_ca.crt
./bin/elasticsearch-users useradd logstash --password passwrd1 --roles superuser

bin/elasticsearch-create-enrollment-token --scope kibana
EOF
cat >> config/pipelines.yml <<EOF
- pipeline.id: nginxlog
  pipeline.workers: 2
  pipeline.batch.size: 125
  pipeline.batch.delay: 50
  path.config: "config/logstash.ngx.conf"
EOF
cat >> config/logstash.ngx.conf <<'EOF'
input {
  udp {
    port => 5140
    host => "0.0.0.0"
    type => "syslog"
  }
}
filter {
  if [type] == "syslog" {
    grok {
      match => { "message" => "<%{POSINT:syslog_pri}>%{SYSLOGTIMESTAMP:syslog_timestamp} %{SYSLOGHOST:syslog_hostname} %{PROG:syslog_program}(?:\[%{POSINT:syslog_pid}\])?: %{GREEDYDATA:syslog_message}" }
      add_tag => [ "syslog_parsed_ok" ]
    }
    if [syslog_program] == "ngx_error" {
      grok {
        match => { "syslog_message" => "(?<timestamp>%{YEAR}[./]%{MONTHNUM}[./]%{MONTHDAY} %{TIME}) \[%{LOGLEVEL:log_level}\] %{POSINT:pid}#%{NUMBER:threadid}: \*%{NUMBER:connectionid} %{GREEDYDATA:message_content}, client: %{IP:client_ip}, server: %{GREEDYDATA:server_name}, request: %{GREEDYDATA:log_message}" }
        #\"%{GREEDYDATA:request_details}\"(, upstream: \"%{URI:upstream_server}\")?(, host: \"%{IPORHOST:host}\")?(, referrer: \"%{URI:referrer}\")?
        remove_field => [ "message","syslog_message","event" ]
      }
      date {
        match => [ "timestamp", "YYYY/MM/DD HH:mm:ss" ]
        target => "@timestamp"
        remove_field => [ "timestamp" ]
      }
    }
    if [syslog_program] == "ngx_access" {
      json {
        source => "syslog_message"
        target => "access_log" # Store parsed JSON in a new field
        tag_on_failure => ["json_parsed_error"]
        skip_on_invalid_json => true
        remove_field => [ "message","syslog_message","event" ]
      }
      date {
        match => [ "[access_log][time_iso8601]", "ISO8601" ]
        target => "@timestamp"
        remove_field => [ "[access_log][time_iso8601]" ]
      }
      if [http_x_forwarded_for] {
        geoip {
          source => "http_x_forwarded_for"
          target => "geoip"
        }
      } else if [remote_addr] {
        geoip {
          source => "remote_addr"
          target => "geoip"
        }
      }
    }
  }
}
output {
  if [syslog_program] == "ngx_error" {
    # elasticsearch {
    #   hosts => ["https://localhost:9200"]
    #   index => "nginx-error-%{+YYYY.MM.dd}"
    #   user => "logstash"
    #   password => "passwrd1"
    #   ssl_enabled => true
    #   ssl_certificate_authorities => "http_ca.crt"
    # }
    stdout { codec => rubydebug }
  }
  if [syslog_program] == "ngx_access" {
    # elasticsearch {
    #   hosts => ["localhost:9200"]
    #   index => "nginx-access-%{+YYYY.MM.dd}"
    #   user => "logstash"
    #   password => "passwrd1"
    #   ssl_enabled => true
    #   ssl_certificate_authorities => "http_ca.crt"
    # }
    stdout { codec => rubydebug }
  }
}
EOF
